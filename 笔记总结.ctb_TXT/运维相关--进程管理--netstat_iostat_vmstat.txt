NETSTAT IOSTAT VMSTAT
Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
整体上看，netstat的输出结果可以分为两个部分：

一个是Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。

另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
常见参数
-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态

-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。
    提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ostat
iostat用于输出CPU和磁盘I/O相关的统计信息. 
命令格式:

iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ device [ ... ] | ALL ] [ -p [ device | ALL ]  ]
       [ interval [ count ] ]
1)iostat的 简单使用
iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 
各个输出项目的含义如下:

avg-cpu段:
%user: 在用户级别运行所使用的CPU的百分比.
%nice: nice操作所使用的CPU的百分比.
%sys: 在系统级别(kernel)运行所使用CPU的百分比.
%iowait: CPU等待硬件I/O时,所占用CPU百分比.
%idle: CPU空闲时间的百分比.
Device段:
tps: 每秒钟发送到的I/O请求数.
Blk_read /s: 每秒读取的block数.
Blk_wrtn/s: 每秒写入的block数.
Blk_read:   读入的block总数.
Blk_wrtn:  写入的block总数.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2)iostat参 数说明
iostat各个参数说明:

-c 仅显示CPU统计信息.与-d选项互斥.
 -d 仅显示磁盘统计信息.与-c选项互斥.
 -k 以K为单位显示每秒的磁盘请求数,默认单位块.
 -p device | ALL
  与-x选项互斥,用于显示块设备及系统分区的统计信息.也可以在-p后指定一个设备名,如:
  # iostat -p hda
  或显示所有设备
  # iostat -p ALL
 -t    在输出数据时,打印搜集数据的时间.
 -V    打印版本号和帮助信息.
 -x    输出扩展信息.
3)iostat输 出项目说明
Blk_read
  读入块的当总数.

              Blk_wrtn
  写入块的总数.

              kB_read/s
  每秒从驱动器读入的数据量,单位为K.

              kB_wrtn/s
  每秒向驱动器写入的数据量,单位为K.

              kB_read
  读入的数据总量,单位为K.

              kB_wrtn
  写入的数据总量,单位为K.

              rrqm/s
  将读入请求合并后,每秒发送到设备的读入请求数.

              wrqm/s
  将写入请求合并后,每秒发送到设备的写入请求数.

              r/s
  每秒发送到设备的读入请求数.

              w/s
  每秒发送到设备的写入请求数.

              rsec/s
  每秒从设备读入的扇区数.

              wsec/s
  每秒向设备写入的扇区数.

              rkB/s
  每秒从设备读入的数据量,单位为K.

              wkB/s
  每秒向设备写入的数据量,单位为K.

              avgrq-sz
  发送到设备的请求的平均大小,单位是扇区.

              avgqu-sz
  发送到设备的请求的平均队列长度.

              await
  I/O请求平均执行时间.包括发送请求和执行的时间.单位是毫秒.

              svctm
  发送到设备的I/O请求的平均执行时间.单位是毫秒.

              %util
  在I/O请求发送到设备期间,占用CPU时间的百分比.用于显示设备的带宽利用率.
  当这个值接近100%时,表示设备带宽已经占满.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，
2表示每个两秒采集一次服务器状态，1表示只采集一次。
实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了
vmstat 2  
这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。

好了，命令介绍完毕，现在开始实战讲解每个参数的意思。

r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

free   空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。

buff   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M

cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)

si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。

so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。

bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒

bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

in 每秒CPU的中断次数，包括时间中断

cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。

us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。

sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

wt 等待IO CPU时间。

 

NETSTAT IOSTAT VMSTAT
Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
整体上看，netstat的输出结果可以分为两个部分：

一个是Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。

另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
常见参数
-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态

-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。
    提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ostat
iostat用于输出CPU和磁盘I/O相关的统计信息. 
命令格式:

iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ device [ ... ] | ALL ] [ -p [ device | ALL ]  ]
       [ interval [ count ] ]
1)iostat的 简单使用
iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 
各个输出项目的含义如下:

avg-cpu段:
%user: 在用户级别运行所使用的CPU的百分比.
%nice: nice操作所使用的CPU的百分比.
%sys: 在系统级别(kernel)运行所使用CPU的百分比.
%iowait: CPU等待硬件I/O时,所占用CPU百分比.
%idle: CPU空闲时间的百分比.
Device段:
tps: 每秒钟发送到的I/O请求数.
Blk_read /s: 每秒读取的block数.
Blk_wrtn/s: 每秒写入的block数.
Blk_read:   读入的block总数.
Blk_wrtn:  写入的block总数.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2)iostat参 数说明
iostat各个参数说明:

-c 仅显示CPU统计信息.与-d选项互斥.
 -d 仅显示磁盘统计信息.与-c选项互斥.
 -k 以K为单位显示每秒的磁盘请求数,默认单位块.
 -p device | ALL
  与-x选项互斥,用于显示块设备及系统分区的统计信息.也可以在-p后指定一个设备名,如:
  # iostat -p hda
  或显示所有设备
  # iostat -p ALL
 -t    在输出数据时,打印搜集数据的时间.
 -V    打印版本号和帮助信息.
 -x    输出扩展信息.
3)iostat输 出项目说明
Blk_read
  读入块的当总数.

              Blk_wrtn
  写入块的总数.

              kB_read/s
  每秒从驱动器读入的数据量,单位为K.

              kB_wrtn/s
  每秒向驱动器写入的数据量,单位为K.

              kB_read
  读入的数据总量,单位为K.

              kB_wrtn
  写入的数据总量,单位为K.

              rrqm/s
  将读入请求合并后,每秒发送到设备的读入请求数.

              wrqm/s
  将写入请求合并后,每秒发送到设备的写入请求数.

              r/s
  每秒发送到设备的读入请求数.

              w/s
  每秒发送到设备的写入请求数.

              rsec/s
  每秒从设备读入的扇区数.

              wsec/s
  每秒向设备写入的扇区数.

              rkB/s
  每秒从设备读入的数据量,单位为K.

              wkB/s
  每秒向设备写入的数据量,单位为K.

              avgrq-sz
  发送到设备的请求的平均大小,单位是扇区.

              avgqu-sz
  发送到设备的请求的平均队列长度.

              await
  I/O请求平均执行时间.包括发送请求和执行的时间.单位是毫秒.

              svctm
  发送到设备的I/O请求的平均执行时间.单位是毫秒.

              %util
  在I/O请求发送到设备期间,占用CPU时间的百分比.用于显示设备的带宽利用率.
  当这个值接近100%时,表示设备带宽已经占满.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，
2表示每个两秒采集一次服务器状态，1表示只采集一次。
实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了
vmstat 2  
这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。

好了，命令介绍完毕，现在开始实战讲解每个参数的意思。

r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

free   空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。

buff   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M

cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)

si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。

so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。

bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒

bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

in 每秒CPU的中断次数，包括时间中断

cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。

us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。

sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

wt 等待IO CPU时间。

 

